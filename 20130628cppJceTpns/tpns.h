// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.20 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/joelliu/tpns.jce'
// **********************************************************************

#ifndef __TPNS_H_
#define __TPNS_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "pdu_header.h"
using namespace std;


struct pdu_protocol_header;

namespace TPNS_PUSH_PROTOCOL
{
    enum TPNS_MSG_TYPE
    {
        TYPE_NOTIFY,
        TYPE_TRANSPARENT,
    };
    inline string etos(const TPNS_MSG_TYPE & e)
    {
        switch(e)
        {
            case TYPE_NOTIFY: return "TYPE_NOTIFY";
            case TYPE_TRANSPARENT: return "TYPE_TRANSPARENT";
            default: return "";
        }
    }
    inline int stoe(const string & s, TPNS_MSG_TYPE & e)
    {
        if(s == "TYPE_NOTIFY")  { e=TYPE_NOTIFY; return 0;}
        if(s == "TYPE_TRANSPARENT")  { e=TYPE_TRANSPARENT; return 0;}

        return -1;
    }

    struct NotifyMsg : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.NotifyMsg";
        }
        static string MD5()
        {
            return "b8d49ef409aaddb47e623cb068775fbd";
        }
        NotifyMsg()
        :title(""),content(""),sound(""),lightOn(0),vibrateOn(0)
        {
        }
        void resetDefautlt()
        {
            title = "";
            content = "";
            sound = "";
            lightOn = 0;
            vibrateOn = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(title, 0);
            _os.write(content, 1);
            _os.write(sound, 2);
            _os.write(lightOn, 3);
            _os.write(vibrateOn, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(title, 0, true);
            _is.read(content, 1, true);
            _is.read(sound, 2, false);
            _is.read(lightOn, 3, false);
            _is.read(vibrateOn, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(title,"title");
            _ds.display(content,"content");
            _ds.display(sound,"sound");
            _ds.display(lightOn,"lightOn");
            _ds.display(vibrateOn,"vibrateOn");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(title, true);
            _ds.displaySimple(content, true);
            _ds.displaySimple(sound, true);
            _ds.displaySimple(lightOn, true);
            _ds.displaySimple(vibrateOn, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string title;
        std::string content;
        std::string sound;
        taf::UInt8 lightOn;
        taf::UInt8 vibrateOn;
    };
    inline bool operator==(const NotifyMsg&l, const NotifyMsg&r)
    {
        return l.title == r.title && l.content == r.content && l.sound == r.sound && l.lightOn == r.lightOn && l.vibrateOn == r.vibrateOn;
    }
    inline bool operator!=(const NotifyMsg&l, const NotifyMsg&r)
    {
        return !(l == r);
    }
    int struct_NotifyMsg_pack(NotifyMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_NotifyMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, NotifyMsg * pst_struct, pdu_protocol_header * pdu_header);
    int struct_NotifyMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, NotifyMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TransparentMsg : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TransparentMsg";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        TransparentMsg()
        :msg("")
        {
        }
        void resetDefautlt()
        {
            msg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(msg, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msg, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(msg,"msg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(msg, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string msg;
    };
    inline bool operator==(const TransparentMsg&l, const TransparentMsg&r)
    {
        return l.msg == r.msg;
    }
    inline bool operator!=(const TransparentMsg&l, const TransparentMsg&r)
    {
        return !(l == r);
    }
    int struct_TransparentMsg_pack(TransparentMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TransparentMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TransparentMsg * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TransparentMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TransparentMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsPushPayload : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsPushPayload";
        }
        static string MD5()
        {
            return "461173597b29db3e7316a8db2837217f";
        }
        TpnsPushPayload()
        :type(TPNS_PUSH_PROTOCOL::TYPE_NOTIFY)
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)type, 0);
            _os.write(notifyMsg, 1);
            _os.write(transparentMsg, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            taf::Int32 eTemp0 = TPNS_PUSH_PROTOCOL::TYPE_NOTIFY;
            _is.read(eTemp0, 0, true);
            type = (TPNS_PUSH_PROTOCOL::TPNS_MSG_TYPE)eTemp0;
            _is.read(notifyMsg, 1, false);
            _is.read(transparentMsg, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display((taf::Int32)type,"type");
            _ds.display(notifyMsg,"notifyMsg");
            _ds.display(transparentMsg,"transparentMsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple((taf::Int32)type, true);
            _ds.displaySimple(notifyMsg, true);
            _ds.displaySimple(transparentMsg, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        TPNS_PUSH_PROTOCOL::TPNS_MSG_TYPE type;
        TPNS_PUSH_PROTOCOL::NotifyMsg notifyMsg;
        TPNS_PUSH_PROTOCOL::TransparentMsg transparentMsg;
    };
    inline bool operator==(const TpnsPushPayload&l, const TpnsPushPayload&r)
    {
        return l.type == r.type && l.notifyMsg == r.notifyMsg && l.transparentMsg == r.transparentMsg;
    }
    inline bool operator!=(const TpnsPushPayload&l, const TpnsPushPayload&r)
    {
        return !(l == r);
    }
    int struct_TpnsPushPayload_pack(TpnsPushPayload * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsPushPayload_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushPayload * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsPushPayload_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushPayload * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsPushReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsPushReq";
        }
        static string MD5()
        {
            return "1f5657579a901490b46f40851dce8992";
        }
        TpnsPushReq()
        :accessId(0),msgId(""),token(""),activity("")
        {
        }
        void resetDefautlt()
        {
            accessId = 0;
            msgId = "";
            token = "";
            activity = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(accessId, 0);
            _os.write(msgId, 1);
            _os.write(token, 2);
            _os.write(payload, 3);
            _os.write(activity, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(accessId, 0, true);
            _is.read(msgId, 1, true);
            _is.read(token, 2, true);
            _is.read(payload, 3, true);
            _is.read(activity, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(accessId,"accessId");
            _ds.display(msgId,"msgId");
            _ds.display(token,"token");
            _ds.display(payload,"payload");
            _ds.display(activity,"activity");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(accessId, true);
            _ds.displaySimple(msgId, true);
            _ds.displaySimple(token, true);
            _ds.displaySimple(payload, true);
            _ds.displaySimple(activity, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 accessId;
        std::string msgId;
        std::string token;
        TPNS_PUSH_PROTOCOL::TpnsPushPayload payload;
        std::string activity;
    };
    inline bool operator==(const TpnsPushReq&l, const TpnsPushReq&r)
    {
        return l.accessId == r.accessId && l.msgId == r.msgId && l.token == r.token && l.payload == r.payload && l.activity == r.activity;
    }
    inline bool operator!=(const TpnsPushReq&l, const TpnsPushReq&r)
    {
        return !(l == r);
    }
    int struct_TpnsPushReq_pack(TpnsPushReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsPushReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsPushReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsConfigRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsConfigRsp";
        }
        static string MD5()
        {
            return "0b3922e48a5aa17a9eb63337fcaff280";
        }
        TpnsConfigRsp()
        :connectTimeout(0),recTimeout(0),reConCount(0),reConInterval(0),heartbeatInterval(0)
        {
        }
        void resetDefautlt()
        {
            connectTimeout = 0;
            recTimeout = 0;
            reConCount = 0;
            reConInterval = 0;
            heartbeatInterval = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(connectTimeout, 0);
            _os.write(recTimeout, 1);
            _os.write(reConCount, 2);
            _os.write(reConInterval, 3);
            _os.write(heartbeatInterval, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(connectTimeout, 0, false);
            _is.read(recTimeout, 1, false);
            _is.read(reConCount, 2, false);
            _is.read(reConInterval, 3, false);
            _is.read(heartbeatInterval, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(connectTimeout,"connectTimeout");
            _ds.display(recTimeout,"recTimeout");
            _ds.display(reConCount,"reConCount");
            _ds.display(reConInterval,"reConInterval");
            _ds.display(heartbeatInterval,"heartbeatInterval");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(connectTimeout, true);
            _ds.displaySimple(recTimeout, true);
            _ds.displaySimple(reConCount, true);
            _ds.displaySimple(reConInterval, true);
            _ds.displaySimple(heartbeatInterval, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 connectTimeout;
        taf::UInt32 recTimeout;
        taf::UInt16 reConCount;
        taf::UInt32 reConInterval;
        taf::UInt32 heartbeatInterval;
    };
    inline bool operator==(const TpnsConfigRsp&l, const TpnsConfigRsp&r)
    {
        return l.connectTimeout == r.connectTimeout && l.recTimeout == r.recTimeout && l.reConCount == r.reConCount && l.reConInterval == r.reConInterval && l.heartbeatInterval == r.heartbeatInterval;
    }
    inline bool operator!=(const TpnsConfigRsp&l, const TpnsConfigRsp&r)
    {
        return !(l == r);
    }
    int struct_TpnsConfigRsp_pack(TpnsConfigRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsConfigRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsConfigRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsConfigRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsConfigRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct DeviceInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.DeviceInfo";
        }
        static string MD5()
        {
            return "2d6621da659a171d0b436bb9bcfe09fe";
        }
        DeviceInfo()
        :imei(""),model(""),os(""),network(""),sdCard(""),sdDouble(""),resolution(""),manu(""),apiLevel("")
        {
        }
        void resetDefautlt()
        {
            imei = "";
            model = "";
            os = "";
            network = "";
            sdCard = "";
            sdDouble = "";
            resolution = "";
            manu = "";
            apiLevel = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(imei, 0);
            _os.write(model, 1);
            _os.write(os, 2);
            _os.write(network, 3);
            _os.write(sdCard, 4);
            _os.write(sdDouble, 5);
            _os.write(resolution, 6);
            _os.write(manu, 7);
            _os.write(apiLevel, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(imei, 0, false);
            _is.read(model, 1, false);
            _is.read(os, 2, false);
            _is.read(network, 3, false);
            _is.read(sdCard, 4, false);
            _is.read(sdDouble, 5, false);
            _is.read(resolution, 6, false);
            _is.read(manu, 7, false);
            _is.read(apiLevel, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(imei,"imei");
            _ds.display(model,"model");
            _ds.display(os,"os");
            _ds.display(network,"network");
            _ds.display(sdCard,"sdCard");
            _ds.display(sdDouble,"sdDouble");
            _ds.display(resolution,"resolution");
            _ds.display(manu,"manu");
            _ds.display(apiLevel,"apiLevel");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(imei, true);
            _ds.displaySimple(model, true);
            _ds.displaySimple(os, true);
            _ds.displaySimple(network, true);
            _ds.displaySimple(sdCard, true);
            _ds.displaySimple(sdDouble, true);
            _ds.displaySimple(resolution, true);
            _ds.displaySimple(manu, true);
            _ds.displaySimple(apiLevel, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string imei;
        std::string model;
        std::string os;
        std::string network;
        std::string sdCard;
        std::string sdDouble;
        std::string resolution;
        std::string manu;
        std::string apiLevel;
    };
    inline bool operator==(const DeviceInfo&l, const DeviceInfo&r)
    {
        return l.imei == r.imei && l.model == r.model && l.os == r.os && l.network == r.network && l.sdCard == r.sdCard && l.sdDouble == r.sdDouble && l.resolution == r.resolution && l.manu == r.manu && l.apiLevel == r.apiLevel;
    }
    inline bool operator!=(const DeviceInfo&l, const DeviceInfo&r)
    {
        return !(l == r);
    }
    int struct_DeviceInfo_pack(DeviceInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsRegisterReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsRegisterReq";
        }
        static string MD5()
        {
            return "13509bec0cb13843b123f1f89b300e45";
        }
        TpnsRegisterReq()
        :accessId(0),accessKey(""),deviceId(""),appCert(""),account(""),ticket(""),deviceType(0)
        {
        }
        void resetDefautlt()
        {
            accessId = 0;
            accessKey = "";
            deviceId = "";
            appCert = "";
            account = "";
            ticket = "";
            deviceType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(accessId, 0);
            _os.write(accessKey, 1);
            _os.write(deviceId, 2);
            _os.write(appCert, 3);
            _os.write(account, 4);
            _os.write(ticket, 5);
            _os.write(deviceType, 6);
            _os.write(deviceInfo, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(accessId, 0, true);
            _is.read(accessKey, 1, true);
            _is.read(deviceId, 2, true);
            _is.read(appCert, 3, true);
            _is.read(account, 4, false);
            _is.read(ticket, 5, false);
            _is.read(deviceType, 6, false);
            _is.read(deviceInfo, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(accessId,"accessId");
            _ds.display(accessKey,"accessKey");
            _ds.display(deviceId,"deviceId");
            _ds.display(appCert,"appCert");
            _ds.display(account,"account");
            _ds.display(ticket,"ticket");
            _ds.display(deviceType,"deviceType");
            _ds.display(deviceInfo,"deviceInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(accessId, true);
            _ds.displaySimple(accessKey, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(appCert, true);
            _ds.displaySimple(account, true);
            _ds.displaySimple(ticket, true);
            _ds.displaySimple(deviceType, true);
            _ds.displaySimple(deviceInfo, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 accessId;
        std::string accessKey;
        std::string deviceId;
        std::string appCert;
        std::string account;
        std::string ticket;
        taf::UInt8 deviceType;
        TPNS_PUSH_PROTOCOL::DeviceInfo deviceInfo;
    };
    inline bool operator==(const TpnsRegisterReq&l, const TpnsRegisterReq&r)
    {
        return l.accessId == r.accessId && l.accessKey == r.accessKey && l.deviceId == r.deviceId && l.appCert == r.appCert && l.account == r.account && l.ticket == r.ticket && l.deviceType == r.deviceType && l.deviceInfo == r.deviceInfo;
    }
    inline bool operator!=(const TpnsRegisterReq&l, const TpnsRegisterReq&r)
    {
        return !(l == r);
    }
    int struct_TpnsRegisterReq_pack(TpnsRegisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsRegisterRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsRegisterRsp";
        }
        static string MD5()
        {
            return "ec46b4fe812169bf527015d089068e34";
        }
        TpnsRegisterRsp()
        :sdkVersion(0)
        {
        }
        void resetDefautlt()
        {
            sdkVersion = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sdkVersion, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sdkVersion, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sdkVersion,"sdkVersion");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sdkVersion, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt8 sdkVersion;
    };
    inline bool operator==(const TpnsRegisterRsp&l, const TpnsRegisterRsp&r)
    {
        return l.sdkVersion == r.sdkVersion;
    }
    inline bool operator!=(const TpnsRegisterRsp&l, const TpnsRegisterRsp&r)
    {
        return !(l == r);
    }
    int struct_TpnsRegisterRsp_pack(TpnsRegisterRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct AppInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.AppInfo";
        }
        static string MD5()
        {
            return "95d528f0975422ffc8e3b739e9eaf8e6";
        }
        AppInfo()
        :accessId(0),accessKey("")
        {
        }
        void resetDefautlt()
        {
            accessId = 0;
            accessKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(accessId, 0);
            _os.write(accessKey, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(accessId, 0, true);
            _is.read(accessKey, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(accessId,"accessId");
            _ds.display(accessKey,"accessKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(accessId, true);
            _ds.displaySimple(accessKey, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 accessId;
        std::string accessKey;
    };
    inline bool operator==(const AppInfo&l, const AppInfo&r)
    {
        return l.accessId == r.accessId && l.accessKey == r.accessKey;
    }
    inline bool operator!=(const AppInfo&l, const AppInfo&r)
    {
        return !(l == r);
    }
    int struct_AppInfo_pack(AppInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_AppInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, AppInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_AppInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, AppInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsUnregisterReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsUnregisterReq";
        }
        static string MD5()
        {
            return "7107630edf5e5ef2cc36f794ec0bb429";
        }
        TpnsUnregisterReq()
        :token(""),deviceId("")
        {
        }
        void resetDefautlt()
        {
            token = "";
            deviceId = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appInfo, 0);
            _os.write(token, 1);
            _os.write(deviceId, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appInfo, 0, true);
            _is.read(token, 1, true);
            _is.read(deviceId, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appInfo,"appInfo");
            _ds.display(token,"token");
            _ds.display(deviceId,"deviceId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appInfo, true);
            _ds.displaySimple(token, true);
            _ds.displaySimple(deviceId, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        TPNS_PUSH_PROTOCOL::AppInfo appInfo;
        std::string token;
        std::string deviceId;
    };
    inline bool operator==(const TpnsUnregisterReq&l, const TpnsUnregisterReq&r)
    {
        return l.appInfo == r.appInfo && l.token == r.token && l.deviceId == r.deviceId;
    }
    inline bool operator!=(const TpnsUnregisterReq&l, const TpnsUnregisterReq&r)
    {
        return !(l == r);
    }
    int struct_TpnsUnregisterReq_pack(TpnsUnregisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsUnregisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUnregisterReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsUnregisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUnregisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsReconnectReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsReconnectReq";
        }
        static string MD5()
        {
            return "17a8b0dd721bbe67f1361adcc5c15fc5";
        }
        TpnsReconnectReq()
        :token(""),deviceId(""),networkType(0)
        {
        }
        void resetDefautlt()
        {
            token = "";
            deviceId = "";
            networkType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(token, 0);
            _os.write(deviceId, 1);
            _os.write(networkType, 2);
            _os.write(unregisterAppList, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(token, 0, true);
            _is.read(deviceId, 1, true);
            _is.read(networkType, 2, true);
            _is.read(unregisterAppList, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(token,"token");
            _ds.display(deviceId,"deviceId");
            _ds.display(networkType,"networkType");
            _ds.display(unregisterAppList,"unregisterAppList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(token, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(networkType, true);
            _ds.displaySimple(unregisterAppList, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string token;
        std::string deviceId;
        taf::UInt8 networkType;
        vector<TPNS_PUSH_PROTOCOL::AppInfo> unregisterAppList;
    };
    inline bool operator==(const TpnsReconnectReq&l, const TpnsReconnectReq&r)
    {
        return l.token == r.token && l.deviceId == r.deviceId && l.networkType == r.networkType && l.unregisterAppList == r.unregisterAppList;
    }
    inline bool operator!=(const TpnsReconnectReq&l, const TpnsReconnectReq&r)
    {
        return !(l == r);
    }
    int struct_TpnsReconnectReq_pack(TpnsReconnectReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsReconnectReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsReconnectReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsReconnectRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsReconnectRsp";
        }
        static string MD5()
        {
            return "ec46b4fe812169bf527015d089068e34";
        }
        TpnsReconnectRsp()
        :sdkVersion(0)
        {
        }
        void resetDefautlt()
        {
            sdkVersion = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sdkVersion, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sdkVersion, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sdkVersion,"sdkVersion");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sdkVersion, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt8 sdkVersion;
    };
    inline bool operator==(const TpnsReconnectRsp&l, const TpnsReconnectRsp&r)
    {
        return l.sdkVersion == r.sdkVersion;
    }
    inline bool operator!=(const TpnsReconnectRsp&l, const TpnsReconnectRsp&r)
    {
        return !(l == r);
    }
    int struct_TpnsReconnectRsp_pack(TpnsReconnectRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsReconnectRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsReconnectRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct TpnsUninstallReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TPNS_PUSH_PROTOCOL.TpnsUninstallReq";
        }
        static string MD5()
        {
            return "3900f345ca772bae0ba5b524712af272";
        }
        TpnsUninstallReq()
        :token(""),deviceId(""),timestamp(0)
        {
        }
        void resetDefautlt()
        {
            token = "";
            deviceId = "";
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appInfo, 0);
            _os.write(token, 1);
            _os.write(deviceId, 2);
            _os.write(timestamp, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appInfo, 0, true);
            _is.read(token, 1, true);
            _is.read(deviceId, 2, true);
            _is.read(timestamp, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appInfo,"appInfo");
            _ds.display(token,"token");
            _ds.display(deviceId,"deviceId");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appInfo, true);
            _ds.displaySimple(token, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        TPNS_PUSH_PROTOCOL::AppInfo appInfo;
        std::string token;
        std::string deviceId;
        taf::UInt32 timestamp;
    };
    inline bool operator==(const TpnsUninstallReq&l, const TpnsUninstallReq&r)
    {
        return l.appInfo == r.appInfo && l.token == r.token && l.deviceId == r.deviceId && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const TpnsUninstallReq&l, const TpnsUninstallReq&r)
    {
        return !(l == r);
    }
    int struct_TpnsUninstallReq_pack(TpnsUninstallReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_TpnsUninstallReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUninstallReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_TpnsUninstallReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUninstallReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



#endif
