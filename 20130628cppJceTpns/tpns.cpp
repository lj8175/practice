// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.20 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/joelliu/tpns.jce'
// **********************************************************************

#include "tpns.h"

extern int pdu_header_pack1(pdu_protocol_header * pdu_header, uint8_t * pui_buff, uint32_t * pi_buff_len);
extern int pdu_header_pack2(uint8_t * pui_buff, uint32_t * pi_buff_len, uint32_t * pi_used_len);
extern int pdu_header_unpack(uint8_t * pui_buff, uint32_t * pi_buff_len, pdu_protocol_header * pdu_header, uint32_t * pi_end_len);

namespace TPNS_PUSH_PROTOCOL
{

    int struct_NotifyMsg_pack(NotifyMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_NotifyMsg_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, NotifyMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_NotifyMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, NotifyMsg * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_NotifyMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_NotifyMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, NotifyMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_NotifyMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TransparentMsg_pack(TransparentMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TransparentMsg_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TransparentMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TransparentMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TransparentMsg * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TransparentMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TransparentMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TransparentMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TransparentMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsPushPayload_pack(TpnsPushPayload * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsPushPayload_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushPayload * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsPushPayload_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushPayload * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsPushPayload_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsPushPayload_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushPayload * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsPushPayload_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsPushReq_pack(TpnsPushReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsPushReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsPushReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsPushReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsPushReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsPushReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsPushReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsConfigRsp_pack(TpnsConfigRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsConfigRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsConfigRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsConfigRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsConfigRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsConfigRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsConfigRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsConfigRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsConfigRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_DeviceInfo_pack(DeviceInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_DeviceInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_DeviceInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_DeviceInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsRegisterReq_pack(TpnsRegisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsRegisterReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsRegisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsRegisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsRegisterRsp_pack(TpnsRegisterRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsRegisterRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsRegisterRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsRegisterRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_AppInfo_pack(AppInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_AppInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, AppInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_AppInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, AppInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_AppInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_AppInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, AppInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_AppInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsUnregisterReq_pack(TpnsUnregisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsUnregisterReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUnregisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsUnregisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUnregisterReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsUnregisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsUnregisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUnregisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsUnregisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsReconnectReq_pack(TpnsReconnectReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsReconnectReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsReconnectReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsReconnectReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsReconnectReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsReconnectReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsReconnectRsp_pack(TpnsReconnectRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsReconnectRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsReconnectRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsReconnectRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsReconnectRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsReconnectRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsReconnectRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_TpnsUninstallReq_pack(TpnsUninstallReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_TpnsUninstallReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUninstallReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_TpnsUninstallReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUninstallReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_TpnsUninstallReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_TpnsUninstallReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, TpnsUninstallReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_TpnsUninstallReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

